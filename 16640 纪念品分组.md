# 16640 纪念品分组

链接：https://ac.nowcoder.com/acm/problem/16640
来源：牛客网



## 题目描述

元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。 
 你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。

## 输入描述:

```
第 1 行包括一个整数 w，为每组纪念品价格之和的上限。
第 2 行为一个整数n，表示购来的纪念品的总件数。
第 3 ~ n+2 行每行包含一个正整数 pi ( 5 ≤ pi ≤ w ) ，表示所对应纪念品的价格。
```

## 输出描述:

```
包含一个整数，即最少的分组数目。
```

示例1

## 输入

```
100
9
90
20
20
30
50
60
70
80
90
```

## 输出

```
6
```

## 备注:

```
50%的数据满足：1 ≤ n ≤ 15
100%的数据满足：1 ≤ n ≤ 30000, 80 ≤ w ≤ 200
```



## 解题思路

纪念品按价值降序排列，前后双指针遍历，单一价值超过上限的或者和目前最小价值纪念品相加后超出上限的单独一组，否则两个一组。时间复杂度O(nlogn)，空间复杂度O(n)

注意边界是否取等

1. 结束条件是 `i <= j`
2. `v[i]+v[j] = sum`	符合条件，可以算作一组



```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    int sum, n, ans = 0;
    cin >> sum >> n;
    vector<int> v(n);
    for(int i = 0; i < n; ++i)    cin >> v[i];
    sort(v.rbegin(), v.rend());
    for(int i = 0, j = n-1; i <= j;){
        if(v[i] >= sum || v[i]+v[j] > sum){
            ans++; i++;
        }
        else{
            ans++; i++; j--;
        }
    }
    cout << ans;
    return 0;
}
```

