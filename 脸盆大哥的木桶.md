# 脸盆大哥的木桶



链接：https://ac.nowcoder.com/acm/problem/14670
来源：牛客网



## 题目描述

  彩虹岛网红脸盆大哥最骄傲就是自己制作的木桶。一天𝑙𝑤𝑞拿了𝑛块木板，其中第𝑖块木板的高度为ℎ𝑖，他希望脸盆大哥能够用这些木板制作出精美的木桶。脸盆大哥告诉𝑙𝑤𝑞制作一个木桶需要𝑘块木板，并且所有桶的底面积为𝑠，底面的木板由𝑠𝑙𝑝提供。𝑙𝑤𝑞想知道用这些木块所制作出来的木桶最多能够盛多少体积的水。
 注意，木板不能叠在另一个木板上，且不需要考虑木桶具体是怎么由木板组成的，即是说1块或2块木板也可以组成木桶，底面积仍为𝑠。
 

 

## 输入描述:

```
输入第一行为一个整数𝑇(2 ≤ 𝑇 ≤ 20)，表示一共有𝑇组测试数据。
对于每组测试数据：
第一行有三个整数𝑛(2 ≤ 𝑛 ≤ 103), 𝑘, 𝑠(1 ≤ 𝑛, 𝑘, 𝑠 ≤ 103)，分别表示木板的数量、制作一个木桶所需要的木板数以及木桶的底面积。
第二行有𝑛个整数，其中第𝑖个整数ℎ𝑖(1 ≤ ℎ𝑖 ≤ 103)代表第𝑖个木板的高度。
```

## 输出描述:

```
对于每组测试数据输出一个整数𝑥，代表用这些木板制作的桶最多能装体积为𝑥的水。
```

示例1

## 输入

```
2
4 2 5
1 2 3 4
5 2 5
1 4 5 2 3
```

## 输出

```
20
30
```

## 说明

```
对于第一组样例，第一个桶由第一块木板和第二块木板组成，能够盛水的体积为5，第二个桶由第三块木板和第四块木板组成，能够盛水的体积为15，所以最终体积为20。
对于第二组样例，最后会剩下一块木板无法参与木桶的制作。
```



## 解题思路

贪心+排序：木板高度降序排列，每 k 个一组，这一组的木桶体积由最短的高度决定，最后不足 k 个的舍去；因此遍历数组，取模运算记录第 k 位的高度，累计的高度与底面积相乘就是总的体积。对于每一组数据，读取木板高度的时间复杂度 O(n)，排序的时间复杂度 O(nlogn)，遍历分组的时间复杂度 O(n)，总的时间复杂度 O(nlogn)；空间复杂度 O(n)

**注意每组结束计算后要释放 vector 的内存**



```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main(){
    int t;
    cin >> t;
    for(int i = 0; i < t; ++i){
        int n, k, s, ans = 0;
        cin >> n >> k >> s;
        vector<int> v(n);
        for(int j = 0; j < n; ++j)    cin >> v[j];
        sort(v.rbegin(), v.rend());
        for(int j = 0; j < n; ++j){
            if((j+1) % k == 0)    ans += v[j];
        }
        cout << ans * s << endl;
        vector<int>().swap(v);
    }   
    return 0;
}
```

